"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Blockchain = exports.SANDBOX_CONTRACT_SYMBOL = void 0;
exports.toSandboxContract = toSandboxContract;
const core_1 = require("@ton/core");
const crypto_1 = require("@ton/crypto");
const defaultConfig_1 = require("../config/defaultConfig");
const Executor_1 = require("../executor/Executor");
const BlockchainStorage_1 = require("./BlockchainStorage");
const BlockchainContractProvider_1 = require("./BlockchainContractProvider");
const BlockchainSender_1 = require("./BlockchainSender");
const Treasury_1 = require("../treasury/Treasury");
const message_1 = require("../utils/message");
const slimConfig_1 = require("../config/slimConfig");
const testTreasurySubwalletId_1 = require("../utils/testTreasurySubwalletId");
const collectMetric_1 = require("../metric/collectMetric");
const deepcopy_1 = require("../utils/deepcopy");
const coverage_1 = require("../coverage");
const MessageQueueManager_1 = require("./MessageQueueManager");
const AsyncLock_1 = require("../utils/AsyncLock");
const CREATE_WALLETS_PREFIX = 'CREATE_WALLETS';
function createWalletsSeed(idx) {
    return `${CREATE_WALLETS_PREFIX}${idx}`;
}
const LT_ALIGN = 1000000n;
exports.SANDBOX_CONTRACT_SYMBOL = Symbol('SandboxContract');
/**
 * Provide way to check if contract is in sandbox environment.
 * @param contract Any open contract
 * @throws Error if contract not a sandbox contract
 */
function toSandboxContract(contract) {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if (contract[exports.SANDBOX_CONTRACT_SYMBOL] === true) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return contract;
    }
    throw new Error('Invalid contract: not a sandbox contract');
}
const TREASURY_INIT_BALANCE_TONS = 1_000_000;
function blockchainConfigToBase64(config) {
    switch (config) {
        case 'default':
            return defaultConfig_1.defaultConfig;
        case 'slim':
            return slimConfig_1.slimConfig;
        default:
            return config?.toBoc({ idx: false }).toString('base64') ?? defaultConfig_1.defaultConfig;
    }
}
class Blockchain {
    lock = new AsyncLock_1.AsyncLock();
    storage;
    networkConfig;
    currentLt = 0n;
    currentTime;
    logsVerbosity = {
        print: true,
        blockchainLogs: false,
        vmLogs: 'none',
        debugLogs: true,
    };
    globalLibs;
    contractFetches = new Map();
    nextCreateWalletIndex = 0;
    shouldRecordStorage = false;
    meta;
    prevBlocksInfo;
    randomSeed;
    shouldDebug = false;
    autoDeployLibs;
    transactions = [];
    defaultQueueManager;
    collectCoverage = false;
    coverageTransactions = [];
    coverageGetMethodResults = [];
    executor;
    debuggerExecutor;
    async getDebuggerExecutor() {
        if (!this.debuggerExecutor) {
            this.debuggerExecutor = await Executor_1.Executor.create({ debug: true });
        }
        return this.debuggerExecutor;
    }
    /**
     * Saves snapshot of current blockchain.
     * @example
     * const snapshot = blockchain.snapshot();
     * // some operations
     * await blockchain.loadFrom(snapshot); // restores blockchain state
     */
    snapshot() {
        return {
            contracts: this.storage.knownContracts().map((s) => s.snapshot()),
            networkConfig: this.networkConfig,
            lt: this.currentLt,
            time: this.currentTime,
            verbosity: { ...this.logsVerbosity },
            libs: this.globalLibs,
            nextCreateWalletIndex: this.nextCreateWalletIndex,
            prevBlocksInfo: (0, deepcopy_1.deepcopy)(this.prevBlocksInfo),
            randomSeed: (0, deepcopy_1.deepcopy)(this.randomSeed),
            autoDeployLibs: this.autoDeployLibs,
            transactions: this.transactions.map((tx) => tx),
        };
    }
    /**
     * Restores blockchain state from snapshot.
     * Usage provided in {@link Blockchain#snapshot}.
     *
     * @param snapshot Snapshot of blockchain
     */
    async loadFrom(snapshot) {
        this.storage.clearKnownContracts();
        this.contractFetches.clear();
        for (const contract of snapshot.contracts) {
            const storageContract = await this.getContract(contract.address);
            storageContract.loadFrom(contract);
        }
        this.networkConfig = snapshot.networkConfig;
        this.currentLt = snapshot.lt;
        this.currentTime = snapshot.time;
        this.logsVerbosity = { ...snapshot.verbosity };
        this.globalLibs = snapshot.libs;
        this.nextCreateWalletIndex = snapshot.nextCreateWalletIndex;
        this.prevBlocksInfo = (0, deepcopy_1.deepcopy)(snapshot.prevBlocksInfo);
        this.randomSeed = (0, deepcopy_1.deepcopy)(snapshot.randomSeed);
        this.autoDeployLibs = snapshot.autoDeployLibs;
        this.transactions = snapshot.transactions.map((tx) => tx);
    }
    get recordStorage() {
        return this.shouldRecordStorage;
    }
    /**
     * If set to `true`, [BlockchainTransaction]{@link BlockchainTransaction} will have `oldStorage` and `newStorage` fields.
     *
     * Note that enabling this flag will disable a certain optimization, which will slow down contract emulation
     *
     * @param v
     */
    set recordStorage(v) {
        this.shouldRecordStorage = v;
    }
    get autoDeployLibraries() {
        return this.autoDeployLibs;
    }
    set autoDeployLibraries(value) {
        this.autoDeployLibs = value;
    }
    get debug() {
        return this.shouldDebug;
    }
    set debug(value) {
        this.shouldDebug = value;
    }
    /**
     * @returns Current time in blockchain
     */
    get now() {
        return this.currentTime;
    }
    /**
     * Updates Current time in blockchain.
     * @param now UNIX time to set
     */
    set now(now) {
        this.currentTime = now;
    }
    /**
     * @returns Current logical time in blockchain
     */
    get lt() {
        return this.currentLt;
    }
    constructor(opts) {
        this.networkConfig = blockchainConfigToBase64(opts.config);
        this.executor = opts.executor;
        this.storage = opts.storage;
        this.meta = opts.meta;
        this.autoDeployLibs = opts.autoDeployLibs ?? false;
        this.defaultQueueManager = this.createQueueManager();
    }
    createQueueManager() {
        return new MessageQueueManager_1.MessageQueueManager(this.lock, {
            getContract: (address) => this.getContract(address),
            startFetchingContract: (address) => this.startFetchingContract(address),
            increaseLt: () => this.increaseLt(),
            getLibs: () => this.libs,
            setLibs: (value) => (this.libs = value),
            getAutoDeployLibs: () => this.autoDeployLibs,
            registerTxsForCoverage: (txs) => this.registerTxsForCoverage(txs),
            addTransaction: (transaction) => this.transactions.push(transaction),
        });
    }
    /**
     * @returns Config used in blockchain.
     */
    get config() {
        return core_1.Cell.fromBase64(this.networkConfig);
    }
    /**
     * @returns Config used in blockchain in base64 format.
     */
    get configBase64() {
        return this.networkConfig;
    }
    /**
     * @returns Current PrevBlocksInfo
     */
    get prevBlocks() {
        return (0, deepcopy_1.deepcopy)(this.prevBlocksInfo);
    }
    /**
     * Sets PrevBlocksInfo.
     * @param value PrevBlocksInfo to set
     */
    set prevBlocks(value) {
        this.prevBlocksInfo = (0, deepcopy_1.deepcopy)(value);
    }
    /**
     * @returns The current random seed
     */
    get random() {
        return (0, deepcopy_1.deepcopy)(this.randomSeed);
    }
    /**
     * Sets the random seed
     * @param value A Buffer containing the new random seed
     */
    set random(value) {
        this.randomSeed = (0, deepcopy_1.deepcopy)(value);
    }
    /**
     * Generates and sets a new random seed using secure random bytes.
     */
    async randomize() {
        this.randomSeed = await (0, crypto_1.getSecureRandomBytes)(32);
        return this.randomSeed;
    }
    /**
     * Emulates the result of sending a message to this Blockchain. Emulates the whole chain of transactions before returning the result. Each transaction increases lt by 1000000.
     *
     * @param message Message to send
     * @param params Optional params
     * @returns Result of queue processing
     *
     * @example
     * const result = await blockchain.sendMessage(internal({
     *      from: sender.address,
     *      to: address,
     *      value: toNano('1'),
     *      body: beginCell().storeUint(0, 32).endCell(),
     * }));
     */
    async sendMessage(message, params) {
        await this.defaultQueueManager.pushMessage(message);
        return await this.defaultQueueManager.runQueue(params);
    }
    /**
     * Starts emulating the result of sending a message to this Blockchain (refer to {@link sendMessage}). Each iterator call emulates one transaction, so the whole chain is not emulated immediately, unlike in {@link sendMessage}.
     *
     * @param message Message to send
     * @param params Optional params
     * @param params.allowParallel - When `true`, allows many consequential executions of this method. Useful for emulating interactions based on transaction order (MITM).
     *                        When `false` (default), only one execution of transactions is allowed.
     * @returns Async iterable of {@link BlockchainTransaction}
     *
     * @example
     * const message = internal({
     *     from: sender.address,
     *     to: address,
     *     value: toNano('1'),
     *     body: beginCell().storeUint(0, 32).endCell(),
     * });
     * for await (const tx of await blockchain.sendMessageIter(message, { randomSeed: crypto.randomBytes(32) })) {
     *     // process transaction
     * }
     */
    async sendMessageIter(message, params) {
        const queue = params?.allowParallel ? this.createQueueManager() : this.defaultQueueManager;
        await queue.pushMessage(message);
        // Iterable will lock on per tx basis
        return queue.runQueueIter(true, params);
    }
    /**
     * Runs tick or tock transaction.
     *
     * @param on Address or addresses to run tick-tock
     * @param which Type of transaction (tick or tock)
     * @param [params] Params to run tick tock transaction
     * @returns Result of tick-tock transaction
     *
     * @example
     * let res = await blockchain.runTickTock(address, 'tock');
     */
    async runTickTock(on, which, params) {
        for (const addr of Array.isArray(on) ? on : [on]) {
            await this.defaultQueueManager.pushTickTock(addr, which);
        }
        return await this.defaultQueueManager.runQueue(params);
    }
    /**
     * Runs get method on contract.
     *
     * @param address Address or addresses to run get method
     * @param method MethodId or method name to run
     * @param stack Method params
     * @param [params] Params to run get method
     * @returns Result of get method
     *
     * @example
     * const { stackReader } = await blockchain.runGetMethod(address, 'get_now', [], {
     *     now: 2,
     * });
     * const now = res.stackReader.readNumber();
     */
    async runGetMethod(address, method, stack = [], params) {
        const result = await (await this.getContract(address)).get(method, stack, params);
        this.registerGetMethodForCoverage(result);
        return result;
    }
    /**
     * Retrieves transactions for the specified address. Transactions are ordered from newest to oldest.
     *
     * If both `lt` and `hash` are provided, the result will include transactions up to and including the one matching them.
     *
     * @param {Address} address - The address to retrieve transactions for.
     * @param opts - Options to fetch transactions
     * @param [opts.lt] - Logical time of the transaction to start from. Must be used together with `hash`.
     * @param [opts.hash] - Hash of the transaction to start from. Must be used together with `lt`.
     * @param [opts.limit] - Maximum number of transactions to return.
     *
     * @returns {Promise<BlockchainTransaction[]>} Promise resolving to an array of transactions involving the given address.
     *
     * @throws {Error} If both `lt` and `hash` are provided but no matching transaction is found.
     *
     * @example
     * const transactions = await blockchain.getTransactions(Address.parse(...), {
     *   lt: '1234567890',
     *   hash: 'abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890',
     *   limit: 10
     * });
     */
    async getTransactions(address, opts) {
        const transactionByAddress = this.transactions.reverse().filter((transaction) => {
            const dst = transaction.inMessage?.info?.dest;
            return core_1.Address.isAddress(dst) && dst.equals(address);
        });
        const { lt, hash, limit } = opts ?? {};
        let resultTransactions = transactionByAddress;
        if (lt !== undefined && hash !== undefined) {
            const hashBuffer = typeof hash === 'string' ? Buffer.from(hash, 'hex') : hash;
            const transaction = transactionByAddress.find((tx) => tx.lt === BigInt(lt) && tx.hash() === hashBuffer);
            if (!transaction) {
                throw new Error('Transaction with provided lt and hash not found.');
            }
            resultTransactions = resultTransactions.filter((tx) => tx.lt <= transaction.lt);
        }
        return resultTransactions.slice(0, limit);
    }
    increaseLt() {
        this.currentLt += LT_ALIGN;
    }
    /**
     * Creates new {@link ContractProvider} for contract address.
     *
     * @param address Address to create contract provider for
     * @param init Initial state of contract
     *
     * @example
     * const contractProvider = blockchain.provider(address, init);
     */
    provider(address, init) {
        return new BlockchainContractProvider_1.BlockchainContractProvider({
            getTransactions: (address, opts) => this.getTransactions(address, opts),
            getContract: (addr) => this.getContract(addr),
            pushMessage: (msg) => this.defaultQueueManager.pushMessage(msg),
            runGetMethod: (addr, method, args) => this.runGetMethod(addr, method, args),
            pushTickTock: (on, which) => this.defaultQueueManager.pushTickTock(on, which),
            openContract: (contract) => this.openContract(contract),
        }, address, init);
    }
    /**
     * Creates {@link Sender} for address.
     *
     * Note, that this sender pushes internal messages to Blockchain directly.
     * No value is deducted from sender address, all the values are set to defaults. Use for test purposes only.
     *
     * @example
     * const sender = this.sender(address);
     * await contract.send(sender, ...);
     *
     * @param address Address to create sender for
     */
    sender(address) {
        return new BlockchainSender_1.BlockchainSender({
            pushMessage: (msg) => this.defaultQueueManager.pushMessage(msg),
        }, address);
    }
    treasuryParamsToMapKey(workchain, seed) {
        return `${workchain}:${seed}`;
    }
    /**
     * Creates treasury wallet contract. This wallet is used as alternative to wallet smart contract.
     *
     * @param {string} seed Initial seed for treasury. If the same seed is used to create a treasury, then these treasuries will be identical
     * @param {TreasuryParams} params Params for treasury creation. See {@link TreasuryParams} for more information.
     *
     * @example
     * const wallet = await blockchain.treasury('wallet')
     * await wallet.send({
     *     to: someAddress,
     *     value: toNano('0.5'),
     * });
     */
    async treasury(seed, params) {
        const subwalletId = (0, testTreasurySubwalletId_1.testSubwalletId)(seed);
        const wallet = this.openContract(Treasury_1.TreasuryContract.create(params?.workchain ?? 0, subwalletId));
        const contract = await this.getContract(wallet.address);
        contract.setDebug(false);
        if ((params?.predeploy ?? true) &&
            (contract.accountState === undefined || contract.accountState.type === 'uninit')) {
            await this.sendMessage((0, message_1.internal)({
                from: new core_1.Address(0, Buffer.alloc(32)),
                to: wallet.address,
                value: (0, core_1.toNano)(1),
                stateInit: wallet.init,
            }));
            contract.balance = params?.balance ?? (0, core_1.toNano)(TREASURY_INIT_BALANCE_TONS);
        }
        else if ((params?.resetBalanceIfZero ?? true) && contract.balance === 0n) {
            contract.balance = params?.balance ?? (0, core_1.toNano)(TREASURY_INIT_BALANCE_TONS);
        }
        this.meta?.upsert(wallet.address, { treasurySeed: seed });
        return wallet;
    }
    /**
     * Bulk variant of {@link treasury}.
     * @param n Number of wallets to create
     * @param params Params for treasury creation. See {@link TreasuryParams} for more information.
     * @returns Array of opened treasury contracts
     *
     * @example
     * const [wallet1, wallet2, wallet3] = await blockchain.createWallets(3);
     */
    async createWallets(n, params) {
        const wallets = [];
        for (let i = 0; i < n; i++) {
            const seed = createWalletsSeed(this.nextCreateWalletIndex++);
            wallets.push(await this.treasury(seed, params));
        }
        return wallets;
    }
    /**
     * Opens contract. Returns proxy that substitutes the blockchain Provider in methods starting with get and set.
     *
     * @param contract Contract to open.
     *
     * @example
     * const contract = blockchain.openContract(new Contract(address));
     */
    openContract(contract) {
        let address;
        let init = undefined;
        if (!core_1.Address.isAddress(contract.address)) {
            throw Error('Invalid address');
        }
        address = contract.address;
        if (contract.init) {
            if (!(contract.init.code instanceof core_1.Cell)) {
                throw Error('Invalid init.code');
            }
            if (!(contract.init.data instanceof core_1.Cell)) {
                throw Error('Invalid init.data');
            }
            init = contract.init;
        }
        this.meta?.upsert(address, { wrapperName: contract?.constructor?.name, abi: contract.abi });
        const provider = this.provider(address, init);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return new Proxy(contract, {
            get: (target, prop) => {
                if (prop === exports.SANDBOX_CONTRACT_SYMBOL) {
                    return true;
                }
                const value = target[prop];
                if (typeof prop === 'string' && typeof value === 'function') {
                    const ctx = {
                        contract,
                        methodName: prop,
                    };
                    if (prop.startsWith('get') || prop.startsWith('is')) {
                        return (...args) => value.apply(target, [provider, ...args]);
                    }
                    else if (prop.startsWith('send')) {
                        return async (...args) => {
                            let ret = value.apply(target, [provider, ...args]);
                            if (ret instanceof Promise) {
                                ret = await ret;
                            }
                            const out = {
                                ...(await this.defaultQueueManager.runQueue()),
                                result: ret,
                            };
                            await (0, collectMetric_1.collectMetric)(this, ctx, out);
                            return out;
                        };
                    }
                }
                return value;
            },
        });
    }
    startFetchingContract(address) {
        const addrString = address.toRawString();
        let promise = this.contractFetches.get(addrString);
        if (promise !== undefined) {
            return promise;
        }
        promise = this.storage.getContract(this, address);
        this.contractFetches.set(addrString, promise);
        return promise;
    }
    /**
     * Retrieves {@link SmartContract} from {@link BlockchainStorage}.
     * @param address Address of contract to get
     */
    async getContract(address) {
        try {
            const contract = await this.startFetchingContract(address);
            return contract;
        }
        finally {
            this.contractFetches.delete(address.toRawString());
        }
    }
    /**
     * @returns {LogsVerbosity} level
     */
    get verbosity() {
        return this.logsVerbosity;
    }
    /**
     * Updates logs verbosity level.
     * @param {LogsVerbosity} value
     */
    set verbosity(value) {
        this.logsVerbosity = value;
    }
    /**
     * Updates logs verbosity level for address.
     */
    async setVerbosityForAddress(address, verbosity) {
        const contract = await this.getContract(address);
        contract.setVerbosity(verbosity);
    }
    /**
     * Updates blockchain config
     *
     * @param {BlockchainConfig} config - Custom config in Cell format, or predefined `default` | `slim`
     */
    setConfig(config) {
        this.networkConfig = blockchainConfigToBase64(config);
    }
    async setShardAccount(address, account) {
        const contract = await this.getContract(address);
        contract.account = account;
    }
    /**
     * Retrieves global libs cell
     */
    get libs() {
        return this.globalLibs;
    }
    /**
     * Update global blockchain libs.
     *
     * @param value Cell in libs format: Dictionary<CellHash, Cell>
     *
     * @example
     * const code = await compile('Contract');
     *
     * const libsDict = Dictionary.empty(Dictionary.Keys.Buffer(32), Dictionary.Values.Cell());
     * libsDict.set(code.hash(), code);
     *
     * blockchain.libs = beginCell().storeDictDirect(libsDict).endCell();
     */
    set libs(value) {
        this.globalLibs = value;
    }
    /**
     * Enable coverage collection.
     *
     * @param enable if false, disable coverage collection
     */
    enableCoverage(enable = true) {
        this.collectCoverage = enable;
        this.verbosity.vmLogs = 'vm_logs_verbose';
    }
    /**
     * Returns coverage analysis for the specified contract.
     * Coverage is collected at the TVM assembly instruction level from all executed transactions and get method calls.
     *
     * @param contract Contract to analyze coverage for
     * @returns Coverage object with detailed coverage data
     * @throws Error if the contract has no code
     * @throws Error if verbose VM logs are not enabled (blockchain.verbosity.vmLogs !== "vm_logs_verbose")
     *
     * @example
     * // Enable coverage collection
     * blockchain.enableCoverage();
     *
     * // Execute contract methods
     * await contract.send(sender, { value: toNano('1') }, 'increment');
     *
     * // Get coverage analysis
     * const coverage = blockchain.coverage(contract);
     * const summary = coverage?.summary();
     * console.log(`Coverage: ${summary?.coveragePercentage?.toFixed(2)}%`);
     *
     * // Generate HTML report
     * const htmlReport = coverage?.report("html");
     * await fs.writeFile("coverage.html", htmlReport);
     */
    coverage(contract) {
        const code = contract.init?.code;
        if (!code) {
            throw new Error('No code is available for contract');
        }
        const address = contract.address;
        return this.coverageForCell(code, address);
    }
    registerTxsForCoverage(txs) {
        if (!this.collectCoverage)
            return;
        this.coverageTransactions.push(txs);
    }
    registerGetMethodForCoverage(get) {
        if (!this.collectCoverage)
            return;
        this.coverageGetMethodResults.push(get);
    }
    /**
     * Returns coverage analysis for the specified code cell.
     * This method allows analyzing coverage for code cells directly, with optional address filtering.
     *
     * @param code Cell containing contract code to analyze
     * @param address Optional contract address to filter transactions by.
     *                If provided, only transactions from this address will be analyzed
     * @returns Coverage object with detailed coverage data
     * @throws Error if verbose VM logs are not enabled (blockchain.verbosity.vmLogs !== "vm_logs_verbose")
     *
     * @example
     * blockchain.enableCoverage();
     * // Analyze coverage for a specific code cell
     * const coverage = blockchain.coverageForCell(codeCell, contractAddress);
     *
     * // Analyze coverage for code without address filtering
     * const allCoverage = blockchain.coverageForCell(codeCell);
     *
     * console.log(coverage?.summary());
     */
    coverageForCell(code, address) {
        if (!this.collectCoverage || this.verbosity.vmLogs !== 'vm_logs_verbose') {
            return undefined;
        }
        const txs = this.coverageTransactions.flatMap((tx) => (0, coverage_1.collectTxsCoverage)(code, address, tx));
        const gets = this.coverageGetMethodResults.flatMap((get) => (0, coverage_1.collectAsmCoverage)(code, get.vmLogs));
        const coverages = [...txs, ...gets];
        return new coverage_1.Coverage((0, coverage_1.mergeCoverages)(...coverages));
    }
    /**
     * Creates instance of sandbox blockchain.
     *
     * @param [opts.executor] Custom contract executor. If omitted {@link Executor} is used.
     * @param [opts.config] Config used in blockchain. If omitted {@link defaultConfig} is used.
     * @param [opts.storage] Contracts storage used for blockchain. If omitted {@link LocalBlockchainStorage} is used.
     * @param [opts.meta] Optional contracts metadata provider. If not provided, {@link @ton/test-utils.contractsMeta} will be used to accumulate contracts metadata.
     * @param [opts.autoDeployLibs] Optional flag. If set to true, libraries will be collected automatically
     * @example
     * const blockchain = await Blockchain.create({ config: 'slim' });
     *
     * @example Remote storage
     * let client = new TonClient4({
     *     endpoint: 'https://mainnet-v4.tonhubapi.com'
     * })
     *
     * let blockchain = await Blockchain.create({
     *     storage: new RemoteBlockchainStorage(wrapTonClient4ForRemote(client), 34892000)
     * });
     */
    static async create(opts) {
        return new Blockchain({
            executor: opts?.executor ?? (await Executor_1.Executor.create()),
            storage: opts?.storage ?? new BlockchainStorage_1.LocalBlockchainStorage(),
            // eslint-disable-next-line @typescript-eslint/no-require-imports
            meta: opts?.meta ?? require('@ton/test-utils')?.contractsMeta,
            ...opts,
        });
    }
}
exports.Blockchain = Blockchain;
