"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.collectAsmCoverage = collectAsmCoverage;
exports.collectTxsCoverage = collectTxsCoverage;
const core_1 = require("@ton/core");
const data_1 = require("./data");
const ton_assembly_1 = require("ton-assembly");
function collectAsmCoverage(cell, logs) {
    const [cleanCell, mapping] = recompileCell(cell);
    const info = ton_assembly_1.trace.createMappingInfo(mapping);
    const traceInfos = ton_assembly_1.trace.createTraceInfoPerTransaction(logs, info, undefined);
    const assembly = ton_assembly_1.text.print(ton_assembly_1.runtime.decompileCell(cleanCell));
    const combinedTrace = { steps: traceInfos.flatMap(trace => trace.steps) };
    const combinedLines = (0, data_1.buildLineInfo)(combinedTrace, assembly);
    return {
        code: cell,
        lines: combinedLines,
    };
}
function recompileCell(cell) {
    const instructionsWithoutPositions = ton_assembly_1.runtime.decompileCell(cell);
    const assemblyForPositions = ton_assembly_1.text.print(instructionsWithoutPositions);
    const parseResult = ton_assembly_1.text.parse("out.tasm", assemblyForPositions);
    if (parseResult.$ === "ParseFailure") {
        throw new Error("Cannot parse resulting text Assembly");
    }
    return ton_assembly_1.runtime.compileCellWithMapping(parseResult.instructions);
}
function collectTxsCoverage(code, address, transactions) {
    const results = [];
    for (const transaction of transactions) {
        const txAddress = bigintToAddress(transaction.address);
        if (address !== undefined && txAddress?.toString() !== address.toString()) {
            // other contract transaction, skip
            continue;
        }
        results.push(collectAsmCoverage(code, transaction.vmLogs));
    }
    return results;
}
function bigintToAddress(addr) {
    if (addr === undefined)
        return undefined;
    try {
        const slice = (0, core_1.beginCell)().storeUint(4, 3).storeUint(0, 8).storeUint(addr, 256).asSlice();
        return slice.loadAddress();
    }
    catch {
        return undefined;
    }
}
